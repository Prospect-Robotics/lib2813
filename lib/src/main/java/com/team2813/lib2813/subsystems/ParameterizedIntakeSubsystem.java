package com.team2813.lib2813.subsystems;

import com.google.auto.value.AutoBuilder;
import com.team2813.lib2813.control.ControlMode;
import com.team2813.lib2813.control.Motor;
import com.team2813.lib2813.control.PIDMotor;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

/**
 * A subsystem for an intake mechanism with parameterized motor control.
 *
 * <p>This subsystem uses a {@link Motor} and allows controlling the motor in intake and outtake
 * directions with preconfigured demand values. Commands are provided for common actions such as
 * intaking, outtaking, and stopping the motor.
 */
public abstract class ParameterizedIntakeSubsystem extends SubsystemBase implements AutoCloseable {

  private final PIDMotor intakeMotor;
  private final Params params;

  /**
   * Configuration record that stores the parameters for the intake subsystem.
   *
   * <p>Includes the motor control mode, the intake demand, and the outtake demand.
   *
   * <p>Validation ensures the intake and outtake demands are non-zero and have opposite signs.
   */
  public record Params(ControlMode controlMode, double intakeDemand, double outtakeDemand) {

    /** Returns a builder for creating {@link Params}. Defaults the control mode to VOLTAGE. */
    public static Params.Builder builder() {
      return new AutoBuilder_ParameterizedIntakeSubsystem_Params_Builder() // autogenerated class,
          // ignore if it shows an
          // error in the ide
          .setControlMode(ControlMode.VOLTAGE);
    }

    @AutoBuilder
    public interface Builder {
      Builder setControlMode(ControlMode controlMode);

      Builder setIntakeDemand(double demand);

      Builder setOuttakeDemand(double demand);

      Params build();
    }

    /**
     * Constructs a Params record.
     *
     * @param controlMode the motor control mode, cannot be {@code null}
     * @param intakeDemand the motor demand for intake, must be non-zero
     * @param outtakeDemand the motor demand for outtake, must be non-zero and opposite sign of
     *     intakeDemand
     * @throws IllegalArgumentException if validation fails
     */
    public Params {
      if (controlMode == null) {
        throw new IllegalArgumentException("controlMode cannot be null");
      }
      if (isEssentiallyZero(intakeDemand)) {
        throw new IllegalArgumentException("intakeDemand cannot be zero");
      }
      if (isEssentiallyZero(outtakeDemand)) {
        throw new IllegalArgumentException("outtakeDemand cannot be zero");
      }
      if (Math.signum(intakeDemand) == Math.signum(outtakeDemand)) {
        throw new IllegalArgumentException(
            "intakeDemand should be the opposite sign of outtakeDemand");
      }
    }
  }

  /**
   * Constructs a new intake subsystem.
   *
   * @param intakeMotor the motor controlling the intake mechanism
   * @param params configuration parameters for motor control
   */
  protected ParameterizedIntakeSubsystem(PIDMotor intakeMotor, Params params) {
    this.intakeMotor = intakeMotor;
    this.params = params;
  }

  /**
   * Returns a command that spins the intake wheels in the intake direction.
   *
   * @return an {@link Command} that intakes a game piece
   */
  public final Command intakeItemCommand() {
    return new InstantCommand(this::intakeGamePiece, this);
  }

  /**
   * Returns a command that spins the intake wheels in the outtake direction.
   *
   * @return an {@link InstantCommand} that outtakes a game piece
   */
  public final Command outtakeItemCommand() {
    return new InstantCommand(this::outtakeGamePiece, this);
  }

  /**
   * Returns a command that stops the intake motor.
   *
   * @return an {@link InstantCommand} that stops the motor
   */
  public final Command stopMotorCommand() {
    return new InstantCommand(this::stopMotor, this);
  }

  /** Spins the intake wheels in the configured intake direction. */
  protected final void intakeGamePiece() {
    // FIXME: Maybe add a check that the wheels are not stalled.
    setMotorDemand(params.intakeDemand);
  }

  /** Spins the intake wheels in the configured outtake direction. */
  protected final void outtakeGamePiece() {
    setMotorDemand(params.outtakeDemand);
  }

  /**
   * Runs the intake motor with a specific demand.
   *
   * @param demand the motor demand, meaning depends on the configured {@link ControlMode}
   */
  protected final void setMotorDemand(double demand) {
    intakeMotor.set(params.controlMode, demand);
  }

  /**
   * Returns a command that runs the intake motor with the given demand.
   *
   * @param demand the motor demand, meaning depends on the configured {@link ControlMode}
   * @return a command that sets the motor demand when executed
   */
  protected final Command setMotorDemandCommand(double demand) {
    return new InstantCommand(() -> setMotorDemand(demand), this);
  }

  /** Stops the intake motor. */
  public final void stopMotor() {
    setMotorDemand(0.0);
  }

  @Override
  public void close() {
    // Default implementation does nothing. Override if resources need cleanup.
  }

  /** Returns whether a value is essentially zero (within 0.001). */
  private static boolean isEssentiallyZero(double value) {
    return Math.abs(value) < 0.001;
  }
}
